== Coupled Problems
A *coupled problem* arises when two or more physical phenomena interact with each other in such a way that they cannot be accurately simulated independently. These problems occur when different physics—such as structural deformation, thermal effects, fluid flow, or electromagnetic fields—affect one another in a system, requiring integrated analysis to capture the interactions. Coupling multiple simulations ensures that all relevant physics are modeled simultaneously to reflect real-world behavior.

In engineering, coupled problems are common in systems where different physical domains influence each other. These include fluid-structure interaction (FSI), where fluid flow influences structural deformation, thermo-mechanical analysis, where temperature affects material stress and strain, and multi-body dynamics with flexible bodies, where the motion of rigid bodies interacts with flexible components. The complexity of coupled problems arises from the fact that the solutions to each physical domain must feed back into one another, requiring iterative and often computationally expensive solutions.

#figure(image("Pictures/Coupled Problems.png", width: 60%), caption: "Solution techniques for coupled problems")

The figure above shows different methods to solve a coupled problems.\
There is a co-simulation method used in Flexible MBD where the constraint forces are transferred to FEA for calculating stresses and deformations but it is a one way coupling i.e the FEA code does not send any information back to the MBD code. This method is not the focus of this thesis. This method is called *"Elasto Dynamics"* in literature.



=== Strong Coupling <SC> 
In this method the equations of motion or the equations that govern the individual problems are solved as one large system of equation. Naturally this method will be very hard to solve and computationally expensive.
=== Weak Coupling<IE>
To overcome the issues of strong coupling( @SC  ) a weak coupling is used where the two equations governing the respective phenomena are solved separately. This method although a bit less accurate is easier to implement and solve@MpCCI4711Documentation. Essentially to implement this method one needs to make sure that the two codes / softwares are sharing & using the data generated by each other.
Next the weak coupling can again be divided in two approaches
==== Implicit Coupling 
As the name suggest in this approach a common solution is attained by reducing a error function via an iterative approach. Naturally the two codes share data multiple times in a time-step. The implicit coupling method will make sure that equilibrium is achieved between the two codes.
#figure(image("Pictures/implicit coupling.svg", width: 60%), caption: "Implicit Coupling ")
==== Explicit Coupling
In this method a data is shared between the two codes only once during a timestep. Does not satisfy equilibrium conditions between the two codes.
#figure(image("Pictures/explicit coupling.svg",width: 60%), caption: "Implicit Coupling ")


#pagebreak()
== Multi-Rigid Body Dynamics 
As the name suggests it is the study of multiple bodies interacting with one another in a simulation. The key *assumption* in MBD is that the every body is considered to be *rigid* i.e it cannot deform or change its shape. This assumption reduces the infinite degrees of freedom(DOFs) of a body to 6. So the total DOF's of a system equal $6n$ where $n$ is the number of bodies in the system.  
In MBD a Differential Algebraic equation(DAE) i.e a Differential equation with constraints is solved. These constraints arise from the kinematic constraints like a revolute joint between two bodies. The subsequent sections discuss the theoretical aspects of RBD in detail.


=== Generalized Coordinates
Generalized Coordinates are the coordinates that express the position and orientation of a body in space. These are different from Cartesian coordinates as GCs also give the information about the orientation of a body in space. In 2d 
$arrow(g) in R^3$
and in 3d 
$arrow(g) in R^6$ or $R^7$ depending on the rotational coordinates used.

#figure(image("Pictures/GCs.svg"), caption: "planar generalized coordinates")

From the picture it can be seen that the GSs for the 2d are 
$
arrow(g) = vec(R_o^I,theta, delim: "[")\
R_o^I in R^2\
theta in R^1
$
similarly  in 3D 
$
arrow(g) = vec(R_o^I,q,delim: "[")\
R_o^I in R^3\
q in R^4
$

so the point $S_p$ in the inertial frame can be written as 
$
  S_p^I = R_o^I + A(theta)*S^B_p
$
where $A(theta)$ is a rotation matrix and $S^B_p$ is the position vector of point p in the body reference frame. In 2D A is a function of theta given by 
$
  A(theta) = mat(cos(theta) ,-sin(theta);sin(theta) , cos(theta))
$
This matrix transforms the vector $S_p^B$ which is in the body reference frame to inertial reference frame.
=== Kinematic constraints<constraints>
As a example the equation of revolute joint is explained. A revolute joint constraints two bodies to each other but allows relative rotational motion. 
#figure(image("Pictures/revolute.svg"), caption: "Revolute joint")
The kinematic equation can be written as
$
  S_p^I - S_q^I = 0 \

  = (R_A^I + A(theta_A)*S^B_p) - (R_B^I + A(theta_B)*S^B_q) 
$


=== Differential Algebraic Equations in RBD
The equations of motion in 2D can be given by the following equation
$
  M dot.double(q) + J(q)^T lambda - S(q,dot.double(q)) - Q(t) = 0\
  C(q,t)=0\
  M = mat(m I , m P A(theta)s^('c);
  m s^('c^T)A(theta)^T P^T ,I^') \
  S = vec(dot.double(theta) m  A(theta) s^('c),0)\
  Q = vec(F , n')\
$
$q$ is the vector of generalized coordinates\
$dot.double(q)$ is the vector of generalized Acceleration\
$s^('c)$ is the position of center of gravity in the body frame\
$F$ is the applied force
$n^'$ is the applied torqued or resultant torque\
$I^'$ is the moment of inertia along the z-axis\
$J(q)^T$ is the constraint jacobian\
A more detailed derivation is given in @haugCOMPUTERAIDEDKINEMATICSDYNAMICS
=== Time Integration Methods<Newmark>
There are many ways a DAE can be solved. Firstly a implicit or explicit method needs to be chose. Then depending on the index of the DAE it can either be solved using the original index or index reduction techniques can be used to solve the equation. A DAE is essentially a differential equation with constraints.
In the present work a index 3 implicit method known as the  Newmark's time integration method is used.
Firstly , the equation of motion discussed in the previous chapter can be written as
$
  vec(F(q,dot(q),dot.double(q),lambda,t),
  C(q,t)) = 0
$
This equation can be written in terms of the unknowns as:
$
   vec(F(q_(t_(n+1)),dot(q)_(t_(n+1)),dot.double(q)_(t_(n+1)),lambda_(t_(n+1)),t_(t_(n+1))),
  C(q_(t_(n+1)),t_(n+1))) = 0 \
  \
$
This is a nonlinear equation whose roots satisfy the equation. A root solving method like Newton-Raphson is used. But first the equations need to be discretized in time.
$

  dot(q)_(n+1) (dot.double(q)_(t_(n+1))) = dot(q)_n + (1 - γ) Delta t dot.double(q)_n + γ Delta t dot.double(q)_(n+1) \
  q_(n+1)(dot.double(q)_(t_(n+1))) = q_n + Delta t dot(q)_n + ((1/2 - β) Delta t² dot.double(q)_n) +( β Delta t²/2 dot.double(q)_(n+1) )
$
Substituting (9) in (8) we get everything in terms of 
$
   vec(F(dot.double(q),lambda,t),
   C(dot.double(q),t)) = 0 
$

Solving this equation gives the acceleration and lagrange multipliers which can be substituted back in (9) to get the velocity and position.









#pagebreak()

== Finite element Analysis
The Finite Element Method (FEM) is a powerful numerical technique for solving complex engineering and mathematical problems, particularly those involving differential equations. FEM breaks down a large, complex system into smaller, simpler parts called "finite elements," making it easier to analyze and solve problems with intricate geometries, boundary conditions, and material properties. Here’s an overview of how it works:

+ *Discretization*: The domain (such as a physical structure) is divided into a mesh of elements, often triangles or quadrilaterals in 2D or tetrahedrons and hexahedrons in 3D. Each element represents a small portion of the structure, allowing for the analysis of each part individually.

+ *Approximation of Unknowns*: Within each element, the unknown field (such as displacement, temperature, or stress) is approximated using simple functions called shape functions. These functions are chosen to be continuous across elements, allowing the solution to be represented as a combination of element contributions.

+ *Formulating Equations*: For each element, equations are created based on the governing equations (like those from elasticity theory for structural analysis or thermal equations for heat transfer). These equations often take the form of a system of algebraic equations derived from the minimization of an energy functional or equilibrium conditions.

+ *Assembly of System*: The equations for each element are combined, or "assembled," into a global system of equations representing the entire problem. This assembly process incorporates the boundary conditions and relationships between neighboring elements.

+ *Solution of Equations*: The resulting system of equations is solved numerically, yielding approximate values of the field variable (e.g., displacement in structural analysis) at the nodes of the mesh. From these nodal values, the behavior within each element can be estimated.

+ *Post-Processing*: After solving the equations, results like stresses, strains, or temperatures are derived from the field variable, often using post-processing software to visualize these quantities.

The Finite Element Method is widely used in engineering disciplines, including structural analysis, heat transfer, fluid dynamics, and electromagnetic analysis, as it allows engineers to model and analyze the behavior of complex structures under various conditions.
where.eq


=== Continuum Mechanics<CM>
The strong form or governing differential equation in solid mechanics is given below :
$ sigma(X)_(i j,j) + f_i(X) = rho dot.double(u)(X) "    "  X in Omega \
 "or"\
 sigma(X)_(i j,j) + f_i(X) = 0 " for static analysis"
$ <continuumEq>
$Omega$ is the domain on which the equation is to be solved.And $f$ is the body force.
$ sigma(X)_(i j,j) = C_(i j k l)epsilon_(k l) $
$ epsilon_(k l) = frac(1,2)(F_(l k) F_(k l) - delta_(k l)) $
$ F_(k l)= (dif u_k)/(dif X_l) + delta_(k l)  $
Here $sigma$ is the stress tensor, $C$ is a fourth order tensor that relates stresses and strains. $epsilon$ is the strain tensor. $F$ is the deformation gradient.\
The equation needs boundary conditions that are given by 
$
  sigma_(i j)n_j = f_i in delta Omega_t \
  u_i = hat(u_i) in delta Omega_u
$
These are the prescribed force and displacement boundary conditions. @continuumEq needs to be true at all nodal points and and every time step in case of a transient analysis. And the solution $u_i$ is the vector of displacements that satisfies this requirement.

=== Solution Method
These partial differential equations are solved by converting them into a weak form. @Bathe1995FiniteEP The weak form given in Total Lagrangian form is given by 
$
  integral_(V_o)S:delta E " "d V + integral_(V_o) F_b dot delta u " " d V + integral_(A_o) T dot delta u d A +  integral_(V_o) rho delta u dot dot.double(u) d V
$\
$W_("internal") = integral_(V_o)S:delta e " "d V $\
$W_("external") = integral_(V_o) F_b dot delta u " " d V + integral_(A_o) T dot delta u d A$ \

$W_("kinetic") = integral_(V_o) rho delta u dot dot.double(u) d V$\

The equation $W_("internal")$ is nonlinear in nature due to type of strain measure used. So these equations can be written as  
$
M dot.double(u) + R_("int")(u) + F_("ext") = 0
$
Or in static case 
$
  R_("int")(u) + F_("ext") = 0
$
But if the small strain assumption is used i.e $d u approx.eq 0$ or very small , then the higher order terms can be ignored and the equation can be linearized.
$
 M dot.double(u) + R_("int")(u) + F_("ext") = 0 
$
for transient analysis and 
$
  K u = F_("ext") 
$
in the static case.


#pagebreak()


